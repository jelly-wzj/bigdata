---
layout: post
title:  "虚拟机类加载机制"
date:   2021-04-11 11:00
categories: jvm
permalink: /archivers/jvm-classloader
---

java虚拟机是如何加载ＣＬＡＳＳ文件，ＣＬＡＳＳ文件信息进入虚拟机后会发生什么样的变化？



##### 类的加载方式

* 静态加载

  ```java
  Person p = new Person(); // 静态加载
  ```

* 动态加载

  ```java
  Person p = Class.forName("Person").newInstance(); // 动态加载
  ```

##### 类的加载时机
* 加载，验证，准备，初始化，卸载这５个阶段的顺序是一定的;解析阶段可用在初始化之后开始，为了实现动态绑定

* 初始化触发条件
  - 遇到new,getstatic,putstatic,invokestatic这4条字节码指令时;
    new 一个实例对象;
    读取，设置一个静态变量;
    调用静态方法
  - 使用java.lang.reflect包的方法对进行反射调用时;
  - 当初始化类时，其父类还没初始化，则先触发父类初始化;
  - 当虚拟机启动时，执行main方法，则先初始化则个主类;
  - 当使用jdk17的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄所对应的类没有被初始化，则先要初始化这个类;
  
  **这5种会触发类进行初始化的场景称之为主动引用;其他的引用称之为被动引用．**
  
  *被动引用*
  
  **1)、通过子类引用父类的静态字段，不会导致子类初始化**
  
  ```java
  public class SSClass{
      static{
          System.out.println("SSClass");
      }
  }  
  
  public class SClass extends SSClass{
      static{
          System.out.println("SClass init!");
      }
  
      public static int value = 123;
  
      public SClass(){
          System.out.println("init SClass");
      }
  }
  
  public class SubClass extends SClass{
      static{
          System.out.println("SubClass init");
      }
  
      static int a;
  
      public SubClass(){
          System.out.println("init SubClass");
      }
  }
  
  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(SubClass.value);
      }
  }/* Output: 
          SSClass
          SClass init!
          123     
   *///:~
  
  ```
  
  **2)、通过数组定义来引用类，不会触发此类的初始化**
  
  ```java
  public class NotInitialization{
      public static void main(String[] args){
          SClass[] sca = new SClass[10];
      }
  }
  ```
  
  **3)、常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化**
  
  ```java
  public class ConstClass{
  
      static{
          System.out.println("ConstClass init!");
      }
  
      public static  final String CONSTANT = "hello world";
  }
  
  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(ConstClass.CONSTANT);
      }
  }/* Output: 
          hello world
   *///:~
  
  ```
  
  

##### 类的生命周期

1. 加载

   在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下三件事情：

   　　(1). 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：ZIP包、网络、动态生成、数据库、JSP等文件生成等）；

   　　(2). 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

   　　(3). 在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

   加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

2. 验证

   验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成4个阶段的检验动作：

   * 文件格式验证：验证字节流是否符合Class文件格式的规范(例如，是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型(tag标签检查)、指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量、CONSTANT_Utf8_info类型的常量中是否有不符合UTF8编码的数据、Class文件中各个部分及文件本身是否有被删除的或附加的其他信息、．．．)

   * 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求(例如：这个类是否有父类，除了java.lang.Object之外、这个类是否继承类不允许继承的类－被final修饰、是否完全实现抽象类或接口中的所有方法、类中的字段方法是否与父类产生矛盾．．．)；

   * 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的;。在第二阶段对元数据信息中的数据类型做完检验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：
     　1.保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。

     　2.保证跳转指令不会跳转到方法体以外的字节码指令上。

     　3.保证方法体中的类型转换是有效的。

   * 符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做是对类自身以外(常量池中的各种符号引用)的信息进行匹配检验，通常需要校验下列内容：

     　1.符号引用中通过字符串描述的全限定名是否能找到对应的类

     　2.在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段

     　3.符号引用中的类、字段、方法的访问性(private、protected、public、default)是否可被当前类访问。

   验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响。如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

3. 准备

4. 解析

5. 初始化

6. 使用

7. 卸载



