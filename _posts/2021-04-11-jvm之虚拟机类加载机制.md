---
layout: post
title:  "虚拟机类加载机制"
date:   2021-04-11 11:00
categories: jvm
permalink: /archivers/jvm-classloader
---

java虚拟机是如何加载ＣＬＡＳＳ文件，ＣＬＡＳＳ文件信息进入虚拟机后会发生什么样的变化？



##### 类的加载方式

* 静态加载

  ```java
  Person p = new Person(); // 静态加载
  ```

* 动态加载

  ```java
  Person p = Class.forName("Person").newInstance(); // 动态加载
  ```

##### 类的加载时机
* 加载，验证，准备，初始化，卸载这５个阶段的顺序是一定的;解析阶段可用在初始化之后开始，为了实现动态绑定

* 初始化触发条件
  - 遇到new,getstatic,putstatic,invokestatic这4条字节码指令时;
    new 一个实例对象;
    读取，设置一个静态变量;
    调用静态方法
  - 使用java.lang.reflect包的方法对进行反射调用时;
  - 当初始化类时，其父类还没初始化，则先触发父类初始化;
  - 当虚拟机启动时，执行main方法，则先初始化则个主类;
  - 当使用jdk17的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄所对应的类没有被初始化，则先要初始化这个类;
  
  **这5种会触发类进行初始化的场景称之为主动引用;其他的引用称之为被动引用．**
  
  *被动引用*
  
  **1)、通过子类引用父类的静态字段，不会导致子类初始化**
  
  ```java
  public class SSClass{
      static{
          System.out.println("SSClass");
      }
  }  
  
  public class SClass extends SSClass{
      static{
          System.out.println("SClass init!");
      }
  
      public static int value = 123;
  
      public SClass(){
          System.out.println("init SClass");
      }
  }
  
  public class SubClass extends SClass{
      static{
          System.out.println("SubClass init");
      }
  
      static int a;
  
      public SubClass(){
          System.out.println("init SubClass");
      }
  }
  
  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(SubClass.value);
      }
  }/* Output: 
          SSClass
          SClass init!
          123     
   *///:~
  
  ```
  
  **2)、通过数组定义来引用类，不会触发此类的初始化**
  
  ```java
  public class NotInitialization{
      public static void main(String[] args){
          SClass[] sca = new SClass[10];
      }
  }
  ```
  
  **3)、常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化**
  
  ```java
  public class ConstClass{
  
      static{
          System.out.println("ConstClass init!");
      }
  
      public static  final String CONSTANT = "hello world";
  }
  
  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(ConstClass.CONSTANT);
      }
  }/* Output: 
          hello world
   *///:~
  
  ```
  
  







##### 类的生命周期

1. 加载
2. 验证
3. 准备
4. 解析
5. 初始化
6. 使用
7. 卸载



