---
layout: post
title:  "虚拟机类加载机制"
date:   2021-04-11 11:00
categories: jvm
permalink: /archivers/jvm-classloader
---

java虚拟机是如何加载ＣＬＡＳＳ文件，ＣＬＡＳＳ文件信息进入虚拟机后会发生什么样的变化？



##### 类的加载方式

* 静态加载

  ```java
  Person p = new Person(); // 静态加载
  ```

* 动态加载

  ```java
  Person p = Class.forName("Person").newInstance(); // 动态加载
  ```

##### 类的加载时机
* 加载，验证，准备，初始化，卸载这５个阶段的顺序是一定的;解析阶段可用在初始化之后开始，为了实现动态绑定

* 初始化触发条件
  - 遇到new,getstatic,putstatic,invokestatic这4条字节码指令时;
    new 一个实例对象;
    读取，设置一个静态变量;
    调用静态方法
  - 使用java.lang.reflect包的方法对进行反射调用时;
  - 当初始化类时，其父类还没初始化，则先触发父类初始化;
  - 当虚拟机启动时，执行main方法，则先初始化则个主类;
  - 当使用jdk17的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄所对应的类没有被初始化，则先要初始化这个类;
  
  **这5种会触发类进行初始化的场景称之为主动引用;其他的引用称之为被动引用．**
  
  *被动引用*
  
  **1)、通过子类引用父类的静态字段，不会导致子类初始化**
  
  ```java
  public class SSClass{
      static{
          System.out.println("SSClass");
      }
  }  
  
  public class SClass extends SSClass{
      static{
          System.out.println("SClass init!");
      }
  
      public static int value = 123;
  
      public SClass(){
          System.out.println("init SClass");
      }
  }
  
  public class SubClass extends SClass{
      static{
          System.out.println("SubClass init");
      }
  
      static int a;
  
      public SubClass(){
          System.out.println("init SubClass");
      }
  }
  
  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(SubClass.value);
      }
  }/* Output: 
          SSClass
          SClass init!
          123     
   *///:~
  
  ```
  
  **2)、通过数组定义来引用类，不会触发此类的初始化**
  
  ```java
  public class NotInitialization{
      public static void main(String[] args){
          SClass[] sca = new SClass[10];
      }
  }
  ```
  
  **3)、常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化**
  
  ```java
  public class ConstClass{
  
      static{
          System.out.println("ConstClass init!");
      }
  
      public static  final String CONSTANT = "hello world";
  }
  
  public class NotInitialization{
      public static void main(String[] args){
          System.out.println(ConstClass.CONSTANT);
      }
  }/* Output: 
          hello world
   *///:~
  
  ```
  
  

##### 类的生命周期

1. 加载s

   在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下三件事情：

   　　(1). 通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：ZIP包、网络、动态生成、数据库、JSP等文件生成等）；

   　　(2). 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；

   　　(3). 在内存中(对于HotSpot虚拟就而言就是方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；

   加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

2. 验证

3. 准备

4. 解析

5. 初始化

6. 使用

7. 卸载



